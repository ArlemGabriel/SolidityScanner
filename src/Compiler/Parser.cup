package Compiler;

import java_cup.runtime.*;
import Compiler.Semantic;

/* -------------------------------- Code -------------------------------- */

parser code
{:    
    private Semantic semantic = new Semantic();
    private Symbol lastToken;
    private int errorCount = 0;
    //private String customMsg = "No aditional information of error was found :(";

    //When a sintax error happens the following function catches it automatically
    public void syntax_error(Symbol token){
        this.lastToken = token;
        int line = token.right + 1;
        int column = token.left + 1;

        String errorMsg = "Sintax Error in line: " + line +", column: "+column+", before or at token: '"+String.valueOf(token) +"'\n";

        report_error(errorMsg,null);
    }

    protected int error_sync_size(){
        return 2;
    }

    public void unrecovered_syntax_error(Symbol token) throws java.lang.Exception{
        int lastLine = this.lastToken.right + 1;
        int lastColumn = this.lastToken.left + 1;
        int currentLine = token.right + 1;
        int currentColumn = token.left + 1;

        String errorMsg = "\nCouldn't recover from Sintax Error:\n"+
                           "Last token in line: " + lastLine +", column: "+lastColumn+", token: '"+this.lastToken.value+"'\n"+
                           "Current token in line: " + currentLine +", column: "+currentColumn+", token: '"+String.valueOf(token)+"'\n"+
                           "Probably missing closing bracket\n"+
                           "\nLo siento profe, parece que nos falto tomar un error en cuenta :( \n\n";
        
        report_error(errorMsg,null);
    }

    public void print_error(String msg){
        report_error(msg+"\n\n", null);
    }

    public void add_error_count(){
        errorCount += 1;
    }

    public void print_error_count(){
        if(errorCount > 1){
            report_error(errorCount +" SINTAX ERRORS FOUND\n\n", null);
        }
        else if(errorCount == 1){
            report_error(errorCount +" SINTAX ERROR FOUND\n", null);
        }
        else{
            System.out.println("0 SINTAX ERROR FOUND\n");
        }
    }
:}

/* -------------------------------- Terminals -------------------------------- */
terminal    PRAGMA, SOLIDITY, CONSREAL;                                               //Head
terminal    SEMICOLON, LBRACKET, RBRACKET, LBRACE, RBRACE, LPAREN, RPAREN;            //Grammar symbols
terminal    COMMA, DOT, QUESTIONSIGN, COLON;                                          //Grammar symbols
terminal    BOOL, BYTE, BYTES, ADDRESS, STRING, UFIXED, INTWITHSIGN, INTWITHOUTSIGN;  //Types
terminal    PUBLIC, PRIVATE, PAYABLE, INTERNAL;                                       //Modifiers
terminal    CONTRACT, ENUM, STRUCT, FUNCTION, RETURNS, RETURN, THIS;                  //Reserved words
terminal    WHILE, FOR, DO, IF, ELSE, BREAK, CONTINUE;                                //Control structures
terminal    CONSSTRING, CONSINTEGER, CONSSCIENT, TRUE, FALSE;                         //Values, constants
terminal    ARITMETICNEGATION, LOGICAND, ARITMETICEXOR, ARITMETICEQUAL ;              //Expressions
terminal    LOGICDISTINCT, LOGICOR, ARITMETICLESSEQUALTHAN, ARITMETICLESSTHAN,EQUAL;  //Expressions
terminal    ARITMETICGREATEREQUALTHAN, ARITMETICGREATERTHAN, ARITMETICAND, ARITMETICOR;//Expressions
terminal    SUM, SUBSTRACTION, MULTIPLICATION, DIVISION, MODULE, EXPONENTIATION;      //Expressions
terminal    SHIFTRIGHT, SHIFTLEFT, SUMEQUAL, SUBEQUAL, MULTIEQUAL;                    //Expressions
terminal    ID;

//Other terminals declared on the scanner but no used on the grammar (because it was simplified)
//They are declared here to avoid errors
terminal    LOGICNEGATION, DIVEQUAL, AS, CONSSTRINGERROR, MULTICOMMENTERROR, HEX, VAR, WEI;
terminal    ESCAPEERROR, CALL, DAYS, FROM, SEND, VIEW, ETHER, HOURS, SZABO, WEEKS;
terminal    YEARS, DELETE, FINNEY, CONSINTEGERHEX, IMPORT, BALANCE, MAPPING, MINUTES, SECONDS;
terminal    CALLCODE, MODIFIER, TRANSFER, CONSTRUCTOR, DELEGATECALL;


/* -------------------------------- Non Terminals -------------------------------- */
non terminal    start_production, head, body, version, version_operator, experimental_version;                         //Start
non terminal    contract, other_contract, contract_block;                                                              //Contract
non terminal    enums, enum_id, other_enum_id;                                                                         //Enums
non terminal    variables, type, array_modifier, array_length, variable_modifier;                                      //Variables
non terminal    structures, aux_variables, other_variables, variable_optional_assignment, value_assignment;
non terminal    functions, function_parameters, other_function_parameters, function_modifier, function_return_value;   //Functions
non terminal    function_block, statements, variable_assignment;                                                       //Function block
non terminal    expression, conditional_expression, rest_of_expression, operator, value_expression;                    //Expression
non terminal    function_call, function_calling_params, other_function_calling_param;                                  //Function call
non terminal    control_structures, while_statement, for_statement, do_while_statement, if_statement, else_statement;  //Control structures
non terminal    loop_statement;
non terminal    return_statement, return_value, value, id_inside_function, id_inside_function_aux;

non terminal    rest_enum, rest_variable, rest_structure, obligatory_variables, rest_function, id_inside_function_aux_2;
non terminal    other_statements, other_structures, other_functions;

/* -------------------------------- Precedences -------------------------------- */
precedence left SUMEQUAL, SUBEQUAL, MULTIEQUAL;
precedence left LOGICOR;
precedence left LOGICAND;
precedence left LOGICDISTINCT, ARITMETICEQUAL;
precedence left ARITMETICGREATERTHAN, ARITMETICLESSTHAN, ARITMETICLESSEQUALTHAN, ARITMETICGREATEREQUALTHAN, DIVEQUAL;
precedence left ARITMETICOR;
precedence left ARITMETICEXOR;
precedence left ARITMETICAND;
precedence left SHIFTRIGHT, SHIFTLEFT;
precedence left SUM, SUBSTRACTION;
precedence left MULTIPLICATION, DIVISION, MODULE;
precedence left EXPONENTIATION;

/* -------------------------------- Grammar -------------------------------- */
start with start_production;

start_production ::= head body {:print_error_count();semantic.print();:}
                    | error body {:print_error("General error or wrong file format");:}
; 
head ::= PRAGMA SOLIDITY version experimental_version SEMICOLON
        | PRAGMA error {:print_error("Version is not defined correctly or there is code outside a contract");add_error_count();:}
        | error SEMICOLON {:print_error("Version missing");add_error_count();:}
;
experimental_version ::= version_operator CONSREAL CONSREAL
                        | CONSREAL CONSREAL
                        | //Empty
;
version ::= version_operator CONSREAL CONSREAL
            | CONSREAL CONSREAL
;
version_operator ::= ARITMETICEXOR 
                    | ARITMETICNEGATION
                    | ARITMETICGREATEREQUALTHAN
                    | ARITMETICGREATERTHAN
                    | ARITMETICLESSTHAN
                    | ARITMETICLESSEQUALTHAN
                    | LOGICDISTINCT
;

body ::= contract other_contract
;
other_contract ::= body | //Empty
;

// *** Contract ***
contract ::= CONTRACT ID LBRACKET contract_block RBRACKET
            | error RBRACKET {:print_error("Contract is not defined correctly or there is an error inside it");add_error_count();:}
;
contract_block ::= enums variables structures functions
                //POSIBLE ERRORS ON CONTRACT
               | ID error RBRACKET {:print_error("Variable assignation only can be done inside a function");add_error_count();:}
               | ID error SEMICOLON {:print_error("Variable assignation only can be done inside a function");add_error_count();:}
               | error RBRACKET {:print_error("There is a wrong order of elements inside contract");add_error_count();:}
               | error SEMICOLON {:print_error("There is a wrong order of elements inside contract");add_error_count();:}
               | IF error SEMICOLON {:print_error("If can only be use inside functions");add_error_count();:}
               | IF error RBRACKET {:print_error("If can only be use inside functions");add_error_count();:}
               | ELSE error SEMICOLON {:print_error("Else can only be use inside functions");add_error_count();:}
               | ELSE error RBRACKET {:print_error("Else can only be use inside functions");add_error_count();:}
               | FOR error SEMICOLON {:print_error("For can only be use inside functions");add_error_count();:}
               | FOR error RBRACKET {:print_error("For can only be use inside functions");add_error_count();:}
               | WHILE error SEMICOLON {:print_error("While can only be use inside functions");add_error_count();:}
               | WHILE error RBRACKET {:print_error("While can only be use inside functions");add_error_count();:}
               | DO error SEMICOLON {:print_error("Do while can only be use inside functions");add_error_count();:}
               | DO error RBRACKET {:print_error("Do while can only be use inside functions");add_error_count();:}
;

// *** Enums ***
enums ::= ENUM rest_enum
        | //Empty
;

rest_enum ::= ID LBRACKET enum_id RBRACKET enums 
            | error RBRACKET {:print_error("Emun definition error");add_error_count();:}
;

enum_id ::= ID other_enum_id
            | error {:print_error("Enum error after opening bracket");add_error_count();:}
;
other_enum_id ::= COMMA ID other_enum_id 
                | //Empty
                | COMMA error {:print_error("Enum error inside brackets or missing closing bracket");add_error_count();:}
;

// *** Variables ***
variables ::= type:token {:semantic.rememberType(String.valueOf(token),tokenright+1);:} rest_variable
            | //Empty
;

rest_variable ::= LBRACE array_length RBRACE aux_variables SEMICOLON {:semantic.insertDeclaration();:} variables
                | aux_variables SEMICOLON {:semantic.insertDeclaration();:} variables
;

aux_variables ::=  PUBLIC ID:token {:semantic.rememberId(String.valueOf(token),tokenright+1);:} variable_optional_assignment other_variables
                | PRIVATE ID:token {:semantic.rememberId(String.valueOf(token),tokenright+1);:} variable_optional_assignment other_variables
                | ID:token {:semantic.rememberId(String.valueOf(token),tokenright+1);:} variable_optional_assignment other_variables 
                | ID error {:print_error("Wrong variable definition, probably semicolon missing");add_error_count();:}                
                | error {:print_error("Variable definition error, missing identifier");add_error_count();:}
;

variable_optional_assignment ::= EQUAL value_assignment
                            | EQUAL error {:print_error("Variable definition error, missing value for assignment");add_error_count();:}
                            | //Empty
;

other_variables ::= COMMA aux_variables
                    | //Empty
;

value_assignment ::= value
                    | ID
                    //| error SEMICOLON {:print_error("Variable definition error, missing value for assignment");add_error_count();:}
;

type ::= BOOL:a {:RESULT=a;:}
        | BYTE:a {:RESULT=a;:}
        | BYTES:a {:RESULT=a;:}
        | ADDRESS:a {:RESULT=a;:}
        | STRING:a {:RESULT=a;:}
        | UFIXED:a {:RESULT=a;:}
        | INTWITHSIGN:a {:RESULT=a;:}
        | INTWITHOUTSIGN:a {:RESULT=a;:}
        //| ID
;
array_modifier ::= LBRACE array_length RBRACE
                | //Empty
;
//Easy to modify if it is needed arrays of multiples dimensions
array_length ::= CONSINTEGER
                | //Empty
;
variable_modifier ::= PUBLIC 
                | PRIVATE 
                | //Empty
;

// *** Structures ***
structures ::= STRUCT rest_structure
                | //Empty
;

rest_structure ::= ID LBRACKET obligatory_variables RBRACKET other_structures
                | error RBRACKET {:print_error("Wrong struct definition");add_error_count();:}
;

other_structures ::= STRUCT rest_structure
                | //Empty
                | variables error SEMICOLON {:print_error("Variable definition can't be done after structures");add_error_count();:}
                | variables error RBRACKET {:print_error("Variable definition can't be done after structures");add_error_count();:}
;

obligatory_variables ::= type rest_variable
                        | error SEMICOLON {:print_error("Error with variable definition inside or after of struct");add_error_count();:}
                        | error RBRACKET {:print_error("Error with variable definition inside or after of struct");add_error_count();:}
;

// *** Functions ***
// +++ Functions head +++
functions ::= FUNCTION rest_function
            | //Empty
;

rest_function ::= ID:token {:semantic.actualScopeSum();semantic.insertFunction(String.valueOf(token),tokenright+1);:} LPAREN function_parameters RPAREN function_modifier function_return_value LBRACKET function_block RBRACKET {:semantic.validateFunctionReturn();:} other_functions 
                | error RBRACKET {:print_error("Wrong function definition");add_error_count();:}
;

other_functions ::= FUNCTION rest_function
                 | //Empty
                 | variables error SEMICOLON {:print_error("Variable can't be done after structures");add_error_count();:}
                 | variables error RBRACKET {:print_error("Variable can't be done after structures");add_error_count();:}
;

function_parameters ::= type:token1 {:semantic.rememberType(String.valueOf(token1),token1right+1);:} ID:token2 {:semantic.rememberId(String.valueOf(token2),token2right+1);:} {:semantic.insertDeclaration();:} other_function_parameters
                        | //Empty
                        | error {:print_error("Wrong parameter(s) of function");add_error_count();:}
;
other_function_parameters ::= COMMA type:token1 {:semantic.rememberType(String.valueOf(token1),token1right+1);:} ID:token2 {:semantic.rememberId(String.valueOf(token2),token2right+1);:} {:semantic.insertDeclaration();:}  other_function_parameters 
                            | //Empty
                            | COMMA error {:print_error("Function error with parameter after a comma, probably missing");add_error_count();:}
;
function_modifier ::= PAYABLE 
                    | PRIVATE 
                    | PUBLIC 
                    | INTERNAL 
                    | //Empty
;
function_return_value ::= RETURNS LPAREN type:token1 {:semantic.rememberType(String.valueOf(token1),token1right+1);:} ID:token2 {:semantic.rememberId(String.valueOf(token2),token2right+1);:} RPAREN {:semantic.insertFunctionReturns();:}
                        | //Empty
                        | RETURNS error RPAREN {:print_error("Wrong returns definition");add_error_count();:}
                        | RETURNS error SEMICOLON {:print_error("Wrong returns definition");add_error_count();:}
                        | RETURNS error RBRACKET {:print_error("Wrong returns definition");add_error_count();:}
;
// +++ Functions block +++
function_block ::= variables statements
;
statements ::= variable_assignment other_statements
            | expression SEMICOLON other_statements
            | control_structures other_statements 
            | return_statement other_statements 
            | //Empty
            //POSIBLES ERRORS FOR STATEMENTS INSIDE FUNCTION
            | FUNCTION error SEMICOLON {:print_error("Wrong function block, probably closing bracket of function missing");add_error_count();:}
            | FUNCTION error RBRACKET {:print_error("Wrong function block, probably closing bracket of function missing");add_error_count();:}
            | BREAK error SEMICOLON {:print_error("Break can only be called inside loops");add_error_count();:}
            | BREAK error RBRACKET {:print_error("Break can only be called inside loops");add_error_count();:}
            | CONTINUE error SEMICOLON {:print_error("Continue can only be called inside loops");add_error_count();:}
            | CONTINUE error RBRACKET {:print_error("Continue can only be called inside loops");add_error_count();:}
;

other_statements ::= variable_assignment other_statements
            | expression SEMICOLON other_statements
            | control_structures other_statements 
            | return_statement other_statements 
            | //Empty
            //POSIBLES ERRORS FOR STATEMENTS INSIDE FUNCTION
            | FUNCTION error SEMICOLON {:print_error("Wrong function block, probably closing bracket of function missing");add_error_count();:}
            | FUNCTION error RBRACKET {:print_error("Wrong function block, probably closing bracket of function missing");add_error_count();:}
            | variables error {:print_error("Variables only can be defined at the starts of the function/contract");add_error_count();:}
            | BREAK error SEMICOLON {:print_error("Break can only be called inside loops");add_error_count();:}
            | BREAK error RBRACKET {:print_error("Break can only be called inside loops");add_error_count();:}
            | CONTINUE error SEMICOLON {:print_error("Continue can only be called inside loops");add_error_count();:}
            | CONTINUE error RBRACKET {:print_error("Continue can only be called inside loops");add_error_count();:}
;

// +++ Functions statements +++
// --- Assignment ---
variable_assignment ::= id_inside_function:token {:semantic.rememberDO("VARIABLE", null, String.valueOf(token),tokenright + 1);:} EQUAL:token2 {:semantic.rememberOperator("ARITHMETIC", String.valueOf(token2), token2right + 1);:}  expression SEMICOLON {:semantic.insertVariableDefinition();:}
                        | id_inside_function error SEMICOLON {:print_error("Wrong statement of variable assignment");add_error_count();:}
                        | id_inside_function error RBRACKET {:print_error("Wrong statement of variable assignment");add_error_count();:}
;

// --- Expressions ---
expression ::= LPAREN:token {:semantic.rememberOperator("PRECEDENCE", String.valueOf(token), tokenright + 1);:} expression RPAREN:token2 {:semantic.rememberOperator("PRECEDENCE", String.valueOf(token2), token2right + 1);:} conditional_expression rest_of_expression
		| function_call rest_of_expression
                | value_expression rest_of_expression
                | LOGICNEGATION expression
                | ARITMETICNEGATION expression
                | DELETE expression
                | operator error expression {:print_error("Wrong expression statement, expression expected between operators");add_error_count();:}                
;

conditional_expression ::= QUESTIONSIGN expression COLON expression
				| //EMPTY
                                | QUESTIONSIGN error {:print_error("Wrong conditional expression");add_error_count();:}
;

rest_of_expression ::= operator expression 		
                    | //Empty
                    | operator error expression {:print_error("Wrong expression statement, operator expected between expressions");add_error_count();:}
;

operator ::= LOGICAND
            | ARITMETICEXOR
            | ARITMETICEQUAL:token {:semantic.rememberOperator("BOOLEAN", String.valueOf(token), tokenright + 1);:}
            | LOGICDISTINCT:token {:semantic.rememberOperator("BOOLEAN", String.valueOf(token), tokenright + 1);:}
            | LOGICOR
            | ARITMETICLESSEQUALTHAN:token {:semantic.rememberOperator("BOOLEAN", String.valueOf(token), tokenright + 1);:}
            | ARITMETICLESSTHAN:token {:semantic.rememberOperator("BOOLEAN", String.valueOf(token), tokenright + 1);:}
            | ARITMETICGREATEREQUALTHAN:token {:semantic.rememberOperator("BOOLEAN", String.valueOf(token), tokenright + 1);:}
            | ARITMETICGREATERTHAN:token {:semantic.rememberOperator("BOOLEAN", String.valueOf(token), tokenright + 1);:}
            | ARITMETICAND
            | ARITMETICOR
            | SUM:token {:semantic.rememberOperator("ARITHMETIC", String.valueOf(token), tokenright + 1);:}
            | SUBSTRACTION:token {:semantic.rememberOperator("ARITHMETIC", String.valueOf(token), tokenright + 1);:}
            | MULTIPLICATION
            | DIVISION
            | MODULE
            | EXPONENTIATION
            | SHIFTRIGHT
            | SHIFTLEFT
            | SUMEQUAL
            | SUBEQUAL
            | MULTIEQUAL
            | DIVEQUAL
;

value_expression ::= value
                    | id_inside_function:token {:semantic.rememberDO("VARIABLE", null, String.valueOf(token),tokenright + 1);:}
;

// --- Function calling ---
function_call ::= id_inside_function LPAREN function_calling_params RPAREN
;
function_calling_params ::= expression other_function_calling_param 
                        | //Empty
;
other_function_calling_param ::= COMMA expression
                                | //Empty
;			
// --- Control structures ---
control_structures ::= while_statement 
                        | for_statement 
                        | do_while_statement 
                        | if_statement
;
while_statement ::= WHILE:token {:semantic.rememberWhile(String.valueOf(token),tokenright+1);semantic.actualScopeSum();:} LPAREN expression {:semantic.insertWhile();:}RPAREN LBRACKET loop_statement RBRACKET {:semantic.actualScopeSubtract();semantic.whilesSubtract();:}
                    | WHILE error RBRACKET{:print_error("While wrong definition");add_error_count();:}
;
for_statement ::= FOR LPAREN variable_assignment /*Semicolon on variable_assigment*/ expression SEMICOLON expression RPAREN LBRACKET loop_statement RBRACKET
                | FOR error RBRACKET{:print_error("For wrong definition");add_error_count();:}
;
do_while_statement ::= DO LBRACKET loop_statement RBRACKET WHILE LPAREN expression RPAREN
                    | DO error RBRACKET{:print_error("Do while wrong definition");add_error_count();:}
;
if_statement ::= IF:token {:semantic.rememberIf(String.valueOf(token),tokenright+1);semantic.actualScopeSum();:} LPAREN expression{:semantic.insertIf();:} RPAREN LBRACKET loop_statement RBRACKET{:semantic.actualScopeSubtract();:} else_statement
                | IF error RBRACKET {:print_error("If wrong definition");add_error_count();:}
;
else_statement ::= ELSE:token {:semantic.rememberElse(String.valueOf(token),tokenright+1);semantic.actualScopeSum();semantic.insertElse();:} LBRACKET loop_statement RBRACKET {:semantic.actualScopeSubtract();:}
                   | //Empty
                   | ELSE error RBRACKET {:print_error("Else wrong definition");add_error_count();:}
;
loop_statement ::= variable_assignment loop_statement
                | expression SEMICOLON loop_statement
                | control_structures loop_statement 
                | return_statement loop_statement 
                | BREAK:token {:semantic.insertBreakContinue(String.valueOf(token),tokenright + 1);:} SEMICOLON loop_statement
                | CONTINUE:token1 {:semantic.insertBreakContinue(String.valueOf(token1),token1right + 1);:} SEMICOLON loop_statement
                | //EMPTY
                | error SEMICOLON {:print_error("Error inside loop");add_error_count();:}
                | error RBRACKET {:print_error("Error inside loop");add_error_count();:}
;

// --- Return ---
return_statement ::= RETURN return_value {:semantic.insertFunctionReturn();:} SEMICOLON 
                    | RETURN error {:print_error("Missing return value");add_error_count();:}
;
return_value ::= id_inside_function:token {:semantic.rememberId(String.valueOf(token),tokenright+1);:}
                | value
;
value ::= CONSSTRING:token {:semantic.rememberDO("CONSTANT","CONSSTRING",String.valueOf(token),tokenright + 1);:}
        | CONSINTEGER:token {:semantic.rememberDO("CONSTANT","CONSINTEGER",String.valueOf(token),tokenright + 1);:}
        | CONSSCIENT:token {:semantic.rememberDO("CONSTANT","CONSSCIENT",String.valueOf(token),tokenright + 1);:}
        | TRUE:token {:semantic.rememberDO("CONSTANT","TRUE",String.valueOf(token),tokenright + 1);:}
        | FALSE:token {:semantic.rememberDO("CONSTANT","FALSE",String.valueOf(token),tokenright + 1);:}
;
// --- Aux id for inside functions context ---
id_inside_function ::= ID:a {:RESULT=a;:} id_inside_function_aux
                    | THIS id_inside_function_aux_2
;
id_inside_function_aux ::= DOT ID
                        | DOT THIS
                        | //Empty
                        | DOT error {:print_error("Id error, missing identifier after '.'");add_error_count();:}
;

id_inside_function_aux_2 ::= DOT ID
                        | //Empty
                        | DOT error {:print_error("Id error, missing identifier after '.'");add_error_count();:}
;
