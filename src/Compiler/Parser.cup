package Compiler;

import java_cup.runtime.*;

/* -------------------------------- Code -------------------------------- */
parser code
{:
    private Symbol s;
    //When a sintax error happens the following function catches it automatically
    public void syntax_error(Symbol s){
        this.s =s;
        /*String token = s.value.toString();
        int row = s.right;
        int column = s.left;*/

        //TODO add error
    }

    public Symbol getS(){
        return this.s;
    }
:}

/* -------------------------------- Terminals -------------------------------- */
terminal    PRAGMA, SOLIDITY, CONSREAL;                                               //Head
terminal    SEMICOLON, LBRACKET, RBRACKET, LBRACE, RBRACE, LPAREN, RPAREN;            //Grammar symbols
terminal    COMMA, DOT, QUESTIONSIGN, COLON;                                          //Grammar symbols
terminal    BOOL, BYTE, BYTES, ADDRESS, STRING, UFIXED, INTWITHSIGN, INTWITHOUTSIGN;  //Types
terminal    PUBLIC, PRIVATE, PAYABLE, INTERNAL;                                       //Modifiers
terminal    CONTRACT, ENUM, STRUCT, FUNCTION, RETURNS, RETURN, THIS;                  //Reserved words
terminal    WHILE, FOR, DO, IF, ELSE;                                                 //Control structures
terminal    CONSSTRING, CONSINTEGER, CONSSCIENT, TRUE, FALSE;                         //Values, constants
terminal    ARITMETICNEGATION, LOGICAND, ARITMETICEXOR, ARITMETICEQUAL ;              //Expressions
terminal    LOGICDISTINCT, LOGICOR, ARITMETICLESSEQUALTHAN, ARITMETICLESSTHAN,EQUAL;  //Expressions
terminal    ARITMETICGREATEREQUALTHAN, ARITMETICGREATERTHAN, ARITMETICAND, ARITMETICOR;//Expressions
terminal    SUM, SUBSTRACTION, MULTIPLICATION, DIVISION, MODULE, EXPONENTIATION;      //Expressions
terminal    SHIFTRIGHT, SHIFTLEFT, SUMEQUAL, SUBEQUAL, MULTIEQUAL;                    //Expressions
terminal    ID;

//Other terminals declared on the scanner but no used on the grammar (because it was simplified)
//They are declared here to avoid errors
terminal    LOGICNEGATION, DIVEQUAL, AS, CONSSTRINGERROR, MULTICOMMENTERROR, HEX, VAR, WEI;
terminal    ESCAPEERROR, CALL, DAYS, FROM, SEND, VIEW, BREAK, ETHER, HOURS, SZABO, WEEKS;
terminal    YEARS, DELETE, FINNEY, CONSINTEGERHEX, IMPORT, BALANCE, MAPPING, MINUTES, SECONDS;
terminal    CALLCODE, CONTINUE, MODIFIER, TRANSFER, CONSTRUCTOR, DELEGATECALL;


/* -------------------------------- Non Terminals -------------------------------- */
non terminal    start_production, head, body, version, version_operator, experimental_version;                         //Start
non terminal    contract, other_contract, contract_block;                                                              //Contract
non terminal    enums, enum_id, other_enum_id;                                                                         //Enums
non terminal    variables, type, array_modifier, array_length, variable_modifier;                                      //Variables
non terminal    structures;
non terminal    functions, function_parameters, other_function_parameters, function_modifier, function_return_value;   //Functions
non terminal    function_block, statements, variable_assignment;                                                       //Function block
non terminal    expression, conditional_expression, rest_of_expression, operator, value_expression;                    //Expression
non terminal    function_call, function_calling_params, other_function_calling_param;
non terminal    control_structures, while_statement, for_statement, do_while_statement, if_statement, else_statement;  //Control structures
non terminal    return_statement, return_value, value, id_inside_function, id_inside_function_aux;
non terminal    array_lenght;                                                                                          //Others

/* -------------------------------- Precedences -------------------------------- */
precedence left SUMEQUAL, SUBEQUAL, MULTIEQUAL;
precedence left LOGICOR;
precedence left LOGICAND;
precedence left LOGICDISTINCT, ARITMETICEQUAL;
precedence left ARITMETICGREATERTHAN, ARITMETICLESSTHAN, ARITMETICLESSEQUALTHAN, ARITMETICGREATEREQUALTHAN;
precedence left ARITMETICOR;
precedence left ARITMETICEXOR;
precedence left ARITMETICAND;
precedence left SHIFTRIGHT, SHIFTLEFT;
precedence left SUM, SUBSTRACTION;
precedence left MULTIPLICATION, DIVISION, MODULE;
precedence left EXPONENTIATION;

/* -------------------------------- Grammar -------------------------------- */
start with start_production;

start_production ::= head body
; 
head ::= PRAGMA SOLIDITY version experimental_version SEMICOLON
;
experimental_version ::= version_operator CONSREAL CONSREAL
                        | CONSREAL CONSREAL
                        | //Empty
;
version ::= version_operator CONSREAL CONSREAL
            | CONSREAL CONSREAL
;
version_operator ::= ARITMETICEXOR 
                    | ARITMETICNEGATION
                    | ARITMETICGREATEREQUALTHAN
                    | ARITMETICGREATERTHAN
                    | ARITMETICLESSTHAN
                    | ARITMETICLESSEQUALTHAN
                    | LOGICDISTINCT
;

body ::= contract other_contract 
;
other_contract ::= body | //Empty
;

// *** Contract ***
contract ::= CONTRACT ID LBRACKET contract_block RBRACKET
;
contract_block ::= enums variables structures functions
;

// *** Enums ***
enums ::= ENUM LBRACKET enum_id RBRACKET enums 
        | //Empty
;
enum_id ::= ID other_enum_id 
;
other_enum_id ::= COMMA ID other_enum_id 
                | //Empty
;

// *** Variables ***
variables ::= type array_modifier variable_modifier ID SEMICOLON variables 
            | //Empty
;
type ::= BOOL 
        | BYTE 
        | BYTES 
        | ADDRESS 
        | STRING 
        | UFIXED 
        | INTWITHSIGN 
        | INTWITHOUTSIGN
;
array_modifier ::= LBRACE array_lenght RBRACE | //Empty
;
array_length ::= CONSINTEGER //Easy to modify if it is needed arrays of multiples dimensions
;
variable_modifier ::= PUBLIC 
                | PRIVATE 
                | //Empty
;

// *** Structures ***
structures ::= STRUCT ID LBRACKET variables RBRACKET structures | //Empty
;

// *** Functions ***
// +++ Functions head +++
functions ::= FUNCTION ID LPAREN function_parameters RPAREN function_modifier function_return_value LBRACKET function_block RBRACKET functions 
            | //Empty
;
function_parameters ::= type ID other_function_parameters 
                        | //Empty
;
other_function_parameters ::= COMMA function_parameters 
                            | //Empty
;
function_modifier ::= PAYABLE 
                    | PRIVATE 
                    | PUBLIC 
                    | INTERNAL 
                    | //Empty
;
function_return_value ::= RETURNS LPAREN type ID RPAREN 
                        | //Empty
;
// +++ Functions block +++
function_block ::= variables statements
;
statements ::= variable_assignment statements 
            | expression SEMICOLON statements 
            | control_structures statements 
            | return_statement statements 
            | //Empty
;

// +++ Functions statements +++
// --- Assignment ---
variable_assignment ::= id_inside_function EQUAL expression SEMICOLON
;

// --- Expressions ---
expression ::= LPAREN expression RPAREN conditional_expression rest_of_expression
		| function_call rest_of_expression
                | value_expression rest_of_expression
;

conditional_expression ::= QUESTIONSIGN expression COLON expression
				| //EMPTY
;

rest_of_expression ::= operator expression 				
                    | //Empty
;

operator ::= LOGICAND
            | ARITMETICEXOR
            | ARITMETICEQUAL
            | LOGICDISTINCT
            | LOGICOR
            | ARITMETICLESSEQUALTHAN
            | ARITMETICLESSTHAN
            | ARITMETICGREATEREQUALTHAN
            | ARITMETICGREATERTHAN
            | ARITMETICAND
            | ARITMETICOR
            | SUM
            | SUBSTRACTION
            | MULTIPLICATION
            | DIVISION
            | MODULE
            | EXPONENTIATION
            | SHIFTRIGHT
            | SHIFTLEFT
            | SUMEQUAL
            | SUBEQUAL
            | MULTIEQUAL
;
value_expression ::= value 
                    | id_inside_function
;

// --- Function calling ---
function_call ::= id_inside_function LPAREN function_calling_params RPAREN SEMICOLON
;
function_calling_params ::= id_inside_function other_function_calling_param 
                        | //Empty
;
other_function_calling_param ::= COMMA id_inside_function 
                                | //Empty
;			
// --- Control structures ---
control_structures ::= while_statement 
                        | for_statement 
                        | do_while_statement 
                        | if_statement
;
while_statement ::= WHILE LPAREN expression RPAREN LBRACKET statements RBRACKET
;
for_statement ::= FOR LPAREN variable_assignment SEMICOLON expression SEMICOLON expression RPAREN LBRACKET statements RBRACKET
;
do_while_statement ::= DO LBRACKET statements RBRACKET WHILE LPAREN expression RPAREN
;
if_statement ::= IF LPAREN expression RPAREN LBRACKET statements RBRACKET else_statement
;
else_statement ::= ELSE LBRACKET statements RBRACKET 
                   | //Empty
;
// --- Return ---
return_statement ::= RETURN return_value SEMICOLON
;
return_value ::= id_inside_function 
                | value
;
value ::= CONSSTRING 
        | CONSINTEGER 
        | CONSSCIENT 
        | TRUE 
        | FALSE
;
// --- Aux id for inside functions context ---
id_inside_function ::= ID id_inside_function_aux 
                    | THIS DOT ID 
;
id_inside_function_aux ::= DOT ID 
                        | //Empty
;
