package Compiler;

import java_cup.runtime.*;

/* -------------------------------- Code -------------------------------- */
parser code
{:
    private Symbol s;
    //When a sintax error happens the following function catches it automatically
    public void syntax_error(Symbol s){
        this.s =s;
    }

    public Symbol getS(){
        return this.s;
    }
:}

/* -------------------------------- Terminals -------------------------------- */
terminal    PRAGMA, SOLIDITY, CONSREAL;                                               //Head
terminal    SEMICOLON, LBRACKET, RBRACKET, LBRACE, RBRACE, LPAREN, RPAREN;            //Grammar symbols
terminal    COMMA, DOT, QUESTIONSIGN, COLON;                                          //Grammar symbols
terminal    BOOL, BYTE, BYTES, ADDRESS, STRING, UFIXED, INTWITHSIGN, INTWITHOUTSIGN;  //Types
terminal    PUBLIC, PRIVATE, PAYABLE, INTERNAL;                                       //Modifiers
terminal    CONTRACT, ENUM, STRUCT, FUNCTION, RETURNS, RETURN, THIS;                  //Reserved words
terminal    WHILE, FOR, DO, IF, ELSE, BREAK, CONTINUE;                                //Control structures
terminal    CONSSTRING, CONSINTEGER, CONSSCIENT, TRUE, FALSE;                         //Values, constants
terminal    ARITMETICNEGATION, LOGICAND, ARITMETICEXOR, ARITMETICEQUAL ;              //Expressions
terminal    LOGICDISTINCT, LOGICOR, ARITMETICLESSEQUALTHAN, ARITMETICLESSTHAN,EQUAL;  //Expressions
terminal    ARITMETICGREATEREQUALTHAN, ARITMETICGREATERTHAN, ARITMETICAND, ARITMETICOR;//Expressions
terminal    SUM, SUBSTRACTION, MULTIPLICATION, DIVISION, MODULE, EXPONENTIATION;      //Expressions
terminal    SHIFTRIGHT, SHIFTLEFT, SUMEQUAL, SUBEQUAL, MULTIEQUAL;                    //Expressions
terminal    ID;

//Other terminals declared on the scanner but no used on the grammar (because it was simplified)
//They are declared here to avoid errors
terminal    LOGICNEGATION, DIVEQUAL, AS, CONSSTRINGERROR, MULTICOMMENTERROR, HEX, VAR, WEI;
terminal    ESCAPEERROR, CALL, DAYS, FROM, SEND, VIEW, ETHER, HOURS, SZABO, WEEKS;
terminal    YEARS, DELETE, FINNEY, CONSINTEGERHEX, IMPORT, BALANCE, MAPPING, MINUTES, SECONDS;
terminal    CALLCODE, MODIFIER, TRANSFER, CONSTRUCTOR, DELEGATECALL;


/* -------------------------------- Non Terminals -------------------------------- */
non terminal    start_production, head, body, version, version_operator, experimental_version;                         //Start
non terminal    contract, other_contract, contract_block;                                                              //Contract
non terminal    enums, enum_id, other_enum_id;                                                                         //Enums
non terminal    variables, type, array_modifier, array_length, variable_modifier;                                      //Variables
non terminal    structures, aux_variables, other_variables, variable_optional_assignment, value_assignment;
non terminal    functions, function_parameters, other_function_parameters, function_modifier, function_return_value;   //Functions
non terminal    function_block, statements, variable_assignment;                                                       //Function block
non terminal    expression, conditional_expression, rest_of_expression, operator, value_expression;                    //Expression
non terminal    function_call, function_calling_params, other_function_calling_param;                                  //Function call
non terminal    control_structures, while_statement, for_statement, do_while_statement, if_statement, else_statement;  //Control structures
non terminal    loop_statement;
non terminal    return_statement, return_value, value, id_inside_function, id_inside_function_aux;

/* -------------------------------- Precedences -------------------------------- */
precedence left SUMEQUAL, SUBEQUAL, MULTIEQUAL;
precedence left LOGICOR;
precedence left LOGICAND;
precedence left LOGICDISTINCT, ARITMETICEQUAL;
precedence left ARITMETICGREATERTHAN, ARITMETICLESSTHAN, ARITMETICLESSEQUALTHAN, ARITMETICGREATEREQUALTHAN;
precedence left ARITMETICOR;
precedence left ARITMETICEXOR;
precedence left ARITMETICAND;
precedence left SHIFTRIGHT, SHIFTLEFT;
precedence left SUM, SUBSTRACTION;
precedence left MULTIPLICATION, DIVISION, MODULE;
precedence left EXPONENTIATION;

/* -------------------------------- Grammar -------------------------------- */
start with start_production;

start_production ::= head body
; 
head ::= PRAGMA SOLIDITY version experimental_version SEMICOLON
;
experimental_version ::= version_operator CONSREAL CONSREAL
                        | CONSREAL CONSREAL
                        | //Empty
;
version ::= version_operator CONSREAL CONSREAL
            | CONSREAL CONSREAL
;
version_operator ::= ARITMETICEXOR 
                    | ARITMETICNEGATION
                    | ARITMETICGREATEREQUALTHAN
                    | ARITMETICGREATERTHAN
                    | ARITMETICLESSTHAN
                    | ARITMETICLESSEQUALTHAN
                    | LOGICDISTINCT
;

body ::= contract other_contract 
;
other_contract ::= body | //Empty
;

// *** Contract ***
contract ::= CONTRACT ID LBRACKET contract_block RBRACKET
;
contract_block ::= enums variables structures functions
;

// *** Enums ***
enums ::= ENUM ID LBRACKET enum_id RBRACKET enums 
        | //Empty
;
enum_id ::= ID other_enum_id 
;
other_enum_id ::= COMMA ID other_enum_id 
                | //Empty
;

// *** Variables ***
variables ::= type array_modifier aux_variables SEMICOLON variables
            | //Empty 
;

aux_variables ::=  variable_modifier ID variable_optional_assignment other_variables
;

variable_optional_assignment ::= EQUAL value_assignment
                                | //Empty
;

other_variables ::= COMMA aux_variables
                    | {:System.out.println("PPPPPPPPPPP");:}//Empty
;

value_assignment ::= value {:System.out.println("AAAAAAAAAAAAA");:}
                    | ID {:System.out.println("BBBBBBBBBBBB");:}
;

type ::= BOOL 
        | BYTE 
        | BYTES 
        | ADDRESS 
        | STRING 
        | UFIXED 
        | INTWITHSIGN 
        | INTWITHOUTSIGN {:System.out.println("KKKKKKKKKKKKKKKKKKKKK");:}
        //| ID
;
array_modifier ::= LBRACE array_length RBRACE
                | {:System.out.println("LLLLLLLLLLLLLLL");:}//Empty
;
//Easy to modify if it is needed arrays of multiples dimensions
array_length ::= CONSINTEGER
                | //Empty
;
variable_modifier ::= PUBLIC 
                | PRIVATE 
                | {:System.out.println("JJJJJJJJJJJJJJJJJ");:} //Empty
;

// *** Structures ***
structures ::= STRUCT ID LBRACKET variables RBRACKET structures | //Empty
;

// *** Functions ***
// +++ Functions head +++
functions ::= FUNCTION ID LPAREN function_parameters RPAREN function_modifier function_return_value LBRACKET function_block RBRACKET functions 
            | //Empty
;
function_parameters ::= type ID other_function_parameters 
                        | //Empty
;
other_function_parameters ::= COMMA function_parameters 
                            | //Empty
;
function_modifier ::= PAYABLE 
                    | PRIVATE 
                    | PUBLIC 
                    | INTERNAL 
                    | //Empty
;
function_return_value ::= RETURNS LPAREN type ID RPAREN
                        | //Empty
;
// +++ Functions block +++
function_block ::= variables statements
;
statements ::= variable_assignment statements
            | expression SEMICOLON statements
            | control_structures statements 
            | return_statement statements 
            | {:System.out.println("XXXXXXXXXXXXXXX");:}//Empty 
;

// +++ Functions statements +++
// --- Assignment ---
variable_assignment ::= id_inside_function EQUAL expression SEMICOLON
;

// --- Expressions ---
expression ::= LPAREN expression RPAREN conditional_expression rest_of_expression
		| function_call rest_of_expression
                | value_expression rest_of_expression
                | LOGICNEGATION expression
                | ARITMETICNEGATION expression
                | DELETE expression
;

conditional_expression ::= QUESTIONSIGN expression COLON expression
				| //EMPTY
;

rest_of_expression ::= operator expression 		
                    | {:System.out.println("YYYYYYYYYYYYYY");:}//Empty 
;

operator ::= LOGICAND:a {:System.out.println("OPERATOR: " + a);:}
            | ARITMETICEXOR:a {:System.out.println("OPERATOR: " + a);:}
            | ARITMETICEQUAL:a {:System.out.println("OPERATOR: " + a);:}
            | LOGICDISTINCT:a {:System.out.println("OPERATOR: " + a);:}
            | LOGICOR:a {:System.out.println("OPERATOR: " + a);:}
            | ARITMETICLESSEQUALTHAN:a {:System.out.println("OPERATOR: " + a);:}
            | ARITMETICLESSTHAN:a {:System.out.println("OPERATOR: " + a);:}
            | ARITMETICGREATEREQUALTHAN:a {:System.out.println("OPERATOR: " + a);:}
            | ARITMETICGREATERTHAN:a {:System.out.println("OPERATOR: " + a);:}
            | ARITMETICAND:a {:System.out.println("OPERATOR: " + a);:}
            | ARITMETICOR:a {:System.out.println("OPERATOR: " + a);:}
            | SUM:a {:System.out.println("OPERATOR: " + a);:}
            | SUBSTRACTION:a {:System.out.println("OPERATOR: " + a);:}
            | MULTIPLICATION:a {:System.out.println("OPERATOR: " + a);:}
            | DIVISION:a {:System.out.println("OPERATOR: " + a);:}
            | MODULE:a {:System.out.println("OPERATOR: " + a);:}
            | EXPONENTIATION:a {:System.out.println("OPERATOR: " + a);:}
            | SHIFTRIGHT:a {:System.out.println("OPERATOR: " + a);:}
            | SHIFTLEFT:a {:System.out.println("OPERATOR: " + a);:}
            | SUMEQUAL:a {:System.out.println("OPERATOR: " + a);:}
            | SUBEQUAL:a {:System.out.println("OPERATOR: " + a);:}
            | MULTIEQUAL:a {:System.out.println("OPERATOR: " + a);:}
;
value_expression ::= value {:System.out.println("AAAAAAAAAAAAA");:}
                    | id_inside_function {:System.out.println("BBBBBBBBBBBB");:}
;

// --- Function calling ---
function_call ::= id_inside_function LPAREN function_calling_params RPAREN {:System.out.println("FUNCTION CALL");:}
;
function_calling_params ::= expression other_function_calling_param 
                        | {:System.out.println("ZZZZZZZZZZZZZZ");:}//Empty
;
other_function_calling_param ::= COMMA expression
                                | //Empty
;			
// --- Control structures ---
control_structures ::= while_statement 
                        | for_statement 
                        | do_while_statement 
                        | if_statement
;
while_statement ::= WHILE LPAREN expression RPAREN LBRACKET loop_statement RBRACKET
;
for_statement ::= FOR LPAREN variable_assignment /*Semicolon on variable_assigment*/ expression SEMICOLON expression RPAREN LBRACKET loop_statement RBRACKET
;
do_while_statement ::= DO LBRACKET loop_statement RBRACKET WHILE LPAREN expression RPAREN
;
if_statement ::= IF LPAREN expression RPAREN LBRACKET statements RBRACKET else_statement
;
else_statement ::= ELSE LBRACKET statements RBRACKET 
                   | //Empty
;
loop_statement ::= variable_assignment loop_statement
                | expression SEMICOLON loop_statement
                | control_structures loop_statement 
                | return_statement loop_statement 
                | BREAK SEMICOLON loop_statement
                | CONTINUE SEMICOLON loop_statement
                | //EMPTY
;

// --- Return ---
return_statement ::= RETURN return_value SEMICOLON
;
return_value ::= id_inside_function 
                | value
;
value ::= CONSSTRING 
        | CONSINTEGER 
        | CONSSCIENT 
        | TRUE 
        | FALSE 
;
// --- Aux id for inside functions context ---
id_inside_function ::= ID:a id_inside_function_aux {:System.out.println("CCCCCCCCCCCCC "+a);:}
                    | THIS DOT ID
;
id_inside_function_aux ::= DOT ID
                        | DOT THIS
                        | //Empty 
;
